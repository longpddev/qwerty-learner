[{"name":"fs.Dir","trans":["Class, representing a directory stream. Creators fs.opendir (), fs.openDirSync (), or fsPromises.openDir ()."]},{"name":"fs.Dirent","trans":["The class, in the form of a representation of a directory entry returned from reading, can be a file within a directory or a subdirectory fs.Dir. A directory entry is a combination of a file name and file type pair."]},{"name":"fs.FSWatcher","trans":["class. A successful call to the fs.watch () method returns a new fs.fsWatcher object. All fs.fsWatcher objects emit a 'change' event whenever a specific watch file has been modified."]},{"name":"fs.StatWatcher","trans":["class, a successful call to the fs.watchFile () method returns a new fs.StatWatcher object.  "]},{"name":"fs.ReadStream","trans":["class, using the fs.readstream instance creates and returns fs.createReadStream ()."]},{"name":"fs.Stats","trans":["The class, fs.Stats object, provides information about a file."]},{"name":"fs.WriteStream","trans":["class, an instance using fs.WriteStream creates and returns fs.createWriteStream ()."]},{"name":"fs.access(path[, mode], callback)","trans":["Test the user's permission path to the specified file or directory. The mode parameter is an optional integer that specifies the accessibility check to be performed. Check the possible value mode in the “File Access Constants”. You can create masks that are bitwise or composed of two or more values (for example, fs.constants.w_ok | fs.constants.r_OK).    "]},{"name":"fs.accessSync(path[, mode])","trans":["Simultaneously test the user's permission path to the specified file or directory. The mode parameter is an optional integer that specifies the accessibility check to be performed."]},{"name":"fs.appendFile(path, data[, options], callback)","trans":["Asynchronously append data to a file, and create the file if it doesn't already exist. Data can be a string or Buffer.    "]},{"name":"fs.appendFileSync(path, data[, options])","trans":["Append the data sync to a file, or create the file if it doesn't already exist. Data can be a string or Buffer."]},{"name":"fs.chmod(path, mode, callback)","trans":["Asynchronously change file permissions"]},{"name":"fs.chmodSync(path, mode)","trans":["Change file permissions synchronously"]},{"name":"fs.chown(path, uid, gid, callback)","trans":["Asynchronously change the owner and group of a file."]},{"name":"fs.chownSync(path, uid, gid)","trans":["Change the file's owner and group synchronously."]},{"name":"fs.close(fd, callback)","trans":["Close a file asynchronously"]},{"name":"fs.closeSync(fd)","trans":["Close files synchronously"]},{"name":"fs.constants","trans":["Returns an object containing constants commonly used for file system operations. The specific constants currently defined are described in FS constants."]},{"name":"fs.copyFile(src, dest[, mode], callback)","trans":["Asynchronously copy src to dest. By default, dest is overwritten if it already exists. Other than possible exceptions, no other parameters were given to the callback function. Node.js does not guarantee atomicity of copy operations. If an error occurs after opening the target file for writing, Node.js will attempt to delete the target. mode is an optional integer that specifies the behavior of the copy operation. You can create masks that are bitwise or composed of two or more values, such as fs.constants.copyfile_excl | fs.constants.copyfile_ficClone."]},{"name":"fs.copyFileSync(src, dest[, mode])","trans":["Synchronously copy src to dest. By default, dest is overwritten if it already exists. Returns undefined. Node.js does not guarantee atomicity of copy operations. If an error occurs after opening the target file for writing, Node.js will attempt to delete the target. mode is an optional integer that specifies the behavior of the copy operation. You can create masks that are bitwise or composed of two or more values, such as fs.constants.copyfile_excl | fs.constants.copyfile_ficClone."]},{"name":"fs.createReadStream(path[, options])","trans":["Create a readable stream, the stream returned by this method has a default highWaterMark of 64 kb"]},{"name":"fs.createWriteStream(path[, options])","trans":["Create a writable stream"]},{"name":"fs.exists(path, callback)","trans":["Deprecated: Use fs.stat () or fs.access () instead."]},{"name":"fs.existsSync(path)","trans":["Returns true if the path exists, false otherwise."]},{"name":"fs.fchmod(fd, mode, callback)","trans":["Asynchronous fchmod (2) will change the permissions of the file indicated by the parameter fildes according to the mode permissions of the parameter"]},{"name":"fs.fchmodSync(fd, mode)","trans":["Synchronizing fchmod (2) will change the permissions of the file indicated by the parameter fildes according to the mode permission parameter.  "]},{"name":"fs.fchown(fd, uid, gid, callback)","trans":["Asynchronous fchown (2) will change the owner of the file specified by the parameter fd to the user represented by the parameter owner, and change the group of the file to the parameter group group"]},{"name":"fs.fchownSync(fd, uid, gid)","trans":["Synchronized fchown (2) will change the owner of the file specified by the parameter fd to the user represented by the parameter owner, and change the group of the file to the parameter group group"]},{"name":"fs.fdatasync(fd, callback)","trans":["asynchronous fdatasync (2) to refresh data to disk"]},{"name":"fs.fdatasyncSync(fd)","trans":["synchronized fdatasync (2) to refresh data to disk "]},{"name":"fs.fstat(fd[, options], callback)","trans":["Asynchronous fstat (2). The callback gets two parameters (err, stats) where stats is an fs.stats object. fstat () is the same as stat (), except that the file to be declared specifies fd by the file descriptor."]},{"name":"fs.fstatSync(fd[, options])","trans":["synchronous fstat (2)."]},{"name":"fs.fsync(fd, callback)","trans":["asynchronous fsync (2), synchronizes all modified file data in memory to the storage device"]},{"name":"fs.fsyncSync(fd)","trans":["Synchronous fsync (2) synchronizes all modified file data in memory to the storage device"]},{"name":"fs.ftruncate(fd[, len], callback)","trans":["asynchronous ftruncate (2), change the file size specified by the parameter fd to the size specified by the parameter length"]},{"name":"fs.ftruncateSync(fd[, len])","trans":["ftruncateSync, change the file size specified by the parameter fd to the size specified by the parameter length"]},{"name":"fs.futimes(fd, atime, mtime, callback)","trans":["Change the file system timestamp for the object that the file descriptor points to."]},{"name":"fs.futimesSync(fd, atime, mtime)","trans":["synchronized version of fs.futimes ()"]},{"name":"fs.lchmod(path, mode, callback)","trans":["asynchronous lchmod (2) to modify connection file permissions"]},{"name":"fs.lchmodSync(path, mode)","trans":["synchronized lchmod (2) to modify connection file permissions"]},{"name":"fs.lchown(path, uid, gid, callback)","trans":["An asynchronous lchown (2) function changes the owner and group of a file. If the named file is a symbolic link, lchown () changes the owner or group of the link itself, not the object the link points to. The previous owner or primary group's permission on the object was revoked."]},{"name":"fs.lchownSync(path, uid, gid)","trans":["Synchronous lchown (2), the function changes the owner and group of a file. If the named file is a symbolic link, lchown () changes the owner or group of the link itself, not the object the link points to. The previous owner or primary group's permission on the object was revoked."]},{"name":"fs.lutimes(path, atime, mtime, callback)","trans":["Asynchronously changing a file's timestamp, lutimes () changes the file's access and modification times in the same way as utimes (2). The difference is that if the filename refers to a symbolic link, it doesn't unreference the link: instead, the timestamp of the symbolic link changes."]},{"name":"fs.lutimesSync(path, atime, mtime)","trans":["Synchronously changing the file's timestamp, lutimes () changes the file's access and modification times in the same way as utimes (2). The difference is that if the filename references a symbolic link, it doesn't unreference the link: instead, the symbolic link's timestamp is changed."]},{"name":"fs.link(existingPath, newPath, callback)","trans":["An asynchronous link (2) links one or more object files into an executable file."]},{"name":"fs.linkSync(existingPath, newPath)","trans":["A synchronized link (2) links one or more target files into an executable file."]},{"name":"fs.lstat(path[, options], callback)","trans":["asynchronous lstat (2), get file status"]},{"name":"fs.lstatSync(path[, options])","trans":["synchronized lstat (2), get file status"]},{"name":"fs.mkdir(path[, options], callback)","trans":["Asynchronously create a directory"]},{"name":"fs.mkdirSync(path[, options])","trans":["Create directories synchronously. See also mkdir (2)."]},{"name":"fs.mkdtemp(prefix[, options], callback)","trans":["Create a unique temporary directory."]},{"name":"fs.mkdtempSync(prefix[, options])","trans":["Synchronously create a unique temporary directory."]},{"name":"fs.open(path[, flags[, mode]], callback)","trans":["Open the file asynchronously. See open (2). mode is used to set the file mode (permissions and stickiness), but only when the file is created. On Windows, only write permissions can be manipulated, see fs.chmod ()."]},{"name":"fs.opendir(path[, options], callback)","trans":["Open a directory asynchronously. See opendir (3). "]},{"name":"fs.opendirSync(path[, options])","trans":["Open the catalog synchronously. See opendir (3). "]},{"name":"fs.openSync(path[, flags, mode])","trans":["Open a file synchronously, see open (2)."]},{"name":"fs.read(fd, buffer, offset, length, position, callback)","trans":["Read data from the file specified by fd. buffer is the buffer where data (read from fd) is to be written. offset is the offset at which writing to the buffer starts. length is an integer that specifies the number of bytes to read. The position parameter specifies where to start reading from the file. If position is null, data is read from the current file position and the file position is updated. If position is an integer, then the file position remains the same."]},{"name":"fs.read(fd, [options,] callback)","trans":["Same as fs.read, will accept a synchronized fs object"]},{"name":"fs.readdir(path[, options], callback)","trans":["Asynchronous readdir (3). Read the contents of a directory."]},{"name":"fs.readdirSync(path[, options])","trans":["readdir (3). Read the contents of a directory."]},{"name":"fs.readFile(path[, options], callback)","trans":["Read the entire contents of a file asynchronously.    "]},{"name":"fs.readFileSync(path[, options])","trans":["Read the entire contents of a file synchronously."]},{"name":"fs.readlink(path[, options], callback)","trans":["Asynchronous readlink (2), reads the value of a symbolic link."]},{"name":"fs.readlinkSync(path[, options])","trans":["synchronous readlink (2), reading the value of a symbolic link "]},{"name":"fs.readSync(fd, buffer, offset, length, position)","trans":["fs.read () reads data from the file specified by fd. buffer is the buffer where data (read from fd) is to be written. offset is the offset at which writing to the buffer starts. length is an integer that specifies the number of bytes to read. The position parameter specifies where to start reading from the file. If position is null, data is read from the current file position and the file position is updated. If position is an integer, then the file position remains the same."]},{"name":"fs.readSync(fd, buffer, [options])","trans":["Same as fs.read, will accept a synchronized fs object"]},{"name":"fs.readv(fd, buffers[, position], callback)","trans":["Read data to multiple buffers asynchronously"]},{"name":"fs.readvSync(fd, buffers[, position])","trans":["Read data to multiple buffers synchronously"]},{"name":"fs.realpath(path[, options], callback)","trans":["Asynchronous pass-through analysis.,.. and symbolic links compute canonical path names asynchronously."]},{"name":"fs.realpath.native(path[, options], callback)","trans":["Asynchronous pass-through analysis.,.. and symbolic links compute canonical path names asynchronously. Only paths that can be converted to UTF8 strings are supported.    "]},{"name":"fs.realpathSync(path[, options])","trans":["synchronized fs.realpath ()"]},{"name":"fs.realpathSync.native(path[, options])","trans":["synchronized fs.realpath.native ()"]},{"name":"fs.rename(oldPath, newPath, callback)","trans":["Asynchronously rename the oldPath file to the path name provided by newPath. If newPath already exists, it is overwritten. "]},{"name":"fs.renameSync(oldPath, newPath)","trans":["Synchronously rename the oldPath file to the path name provided by newPath. If newPath already exists, it is overwritten. "]},{"name":"fs.rmdir(path[, options], callback)","trans":["asynchronous rmdir (2)"]},{"name":"fs.rmdirSync(path[, options])","trans":["synchronized rmdir (2)."]},{"name":"fs.rm(path[, options], callback)","trans":["Removes files and directories asynchronously (modeled after the standard POSIX rm utility)."]},{"name":"fs.rmSync(path[, options])","trans":["Synchronously delete files and directories (modeled after the standard POSIX rm utility)."]},{"name":"fs.stat(path[, options], callback)","trans":["asynchronous stat (2)"]},{"name":"fs.statSync(path[, options])","trans":["synchronized stat (2)"]},{"name":"fs.symlink(target, path[, type], callback)","trans":["An asynchronous symlink (2), which creates a link called path that points to the target."]},{"name":"fs.symlinkSync(target, path[, type])","trans":["A synchronized symlink (2), which creates a link called path that points to the target."]},{"name":"fs.truncate(path[, len], callback)","trans":["Asynchronous truncate (2). Truncate the file to the specified length."]},{"name":"fs.truncateSync(path[, len])","trans":["synchronized truncate (2). Truncate the file to the specified length."]},{"name":"fs.unlink(path, callback)","trans":["Removes files or symbolic links asynchronously. "]},{"name":"fs.unlinkSync(path)","trans":["Synchronous unlink (2)."]},{"name":"fs.unwatchFile(filename[, listener])","trans":["Stop watching the filename for changes. If a listener is specified, only this specific listener will be removed; otherwise, all listeners will be removed, stopping watching filename."]},{"name":"fs.utimes(path, atime, mtime, callback)","trans":["Change the file system timestamp of the object pointed to by path.  "]},{"name":"fs.utimesSync(path, atime, mtime)","trans":["Change the file system timestamp of the object pointed to by path. "]},{"name":"fs.watch(filename[, options][, listener])","trans":["Watch for changes in filename, where filename is a file or directory.    "]},{"name":"fs.watchFile(filename[, options], listener)","trans":["Watch for changes to the filename. The listener callback is called every time a file is accessed."]},{"name":"fs.write(fd, buffer[, offset[, length[, position]]], callback)","trans":["Write buffer to the file specified by fd. If buffer is a plain object, then it must have its own toString function property. Offset determines the part of the buffer to be written. Length is an integer that specifies the number of bytes to be written. position specifies the offset at the beginning of the file (where the data is to be written). If typeof position! == 'number', then the data will be written to the current location. See pwrite (2)."]},{"name":"fs.write(fd, string[, position[, encoding]], callback)","trans":["Write a string to the file specified by fd."]},{"name":"fs.writeFile(file, data[, options], callback)","trans":["When file is a file name, data is written to the file asynchronously (overwrite the file if it already exists). The data can be a string or buffer. When file is a file descriptor, it behaves like calling fs.write () directly (recommended)."]},{"name":"fs.writeFileSync(file, data[, options])","trans":["See the documentation for the asynchronous version of this API: fs.writeFile ().    "]},{"name":"fs.writeSync(fd, buffer[, offset[, length[, position]]])","trans":["See the documentation for the asynchronous version of this API: fs.write (fd, buffer...)."]},{"name":"fs.writeSync(fd, string[, position[, encoding]])","trans":["See the documentation for the asynchronous version of this API: fs.write (fd, string...).    "]},{"name":"fs.writev(fd, buffers[, position], callback)","trans":["Use writev () to write an ArrayBufferView array to the file specified by fd."]},{"name":"fs.writevSync(fd, buffers[, position])","trans":["Use writev () to write an ArrayBufferView array to the file specified by fd."]}]